/**
 * Tests generated by Claude
 */
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'

// Import mocks FIRST
import {
  mockWalletNamed,
  mockTestNetWalletNamed,
  mockMainnetWallet,
  mockChipnetWallet,
  localStorageMock,
  mockGetAllWalletsWithNetworkInfo,
  mockDeleteWalletFromDb,
} from './mocks/store.mocks'

// Import store after mocks
import { useStore } from '../src/stores/store'

describe('switchWallet', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    localStorageMock.clear()
    // Create fresh Pinia instance for each test
    setActivePinia(createPinia())
  })

  describe('wallet loading', () => {
    it('loads mainnet wallet when network is mainnet', async () => {
      localStorageMock.setItem('network', 'mainnet')
      mockWalletNamed.mockResolvedValue(mockMainnetWallet)

      const store = useStore()
      // Set initial wallet to avoid "No wallet set" error
      store.setWallet(mockMainnetWallet as never)

      await store.switchWallet('newWallet')

      expect(mockWalletNamed).toHaveBeenCalledWith('newWallet')
      expect(mockTestNetWalletNamed).not.toHaveBeenCalled()
    })

    it('loads chipnet wallet when network is chipnet', async () => {
      localStorageMock.setItem('network', 'chipnet')
      mockTestNetWalletNamed.mockResolvedValue(mockChipnetWallet)

      const store = useStore()
      store.setWallet(mockChipnetWallet as never)

      await store.switchWallet('newWallet')

      expect(mockTestNetWalletNamed).toHaveBeenCalledWith('newWallet')
      expect(mockWalletNamed).not.toHaveBeenCalled()
    })

    it('defaults to mainnet when no network in localStorage', async () => {
      // No network set in localStorage
      mockWalletNamed.mockResolvedValue(mockMainnetWallet)

      const store = useStore()
      store.setWallet(mockMainnetWallet as never)

      await store.switchWallet('newWallet')

      expect(mockWalletNamed).toHaveBeenCalledWith('newWallet')
    })
  })

  describe('state updates', () => {
    beforeEach(() => {
      localStorageMock.setItem('network', 'mainnet')
      mockWalletNamed.mockResolvedValue(mockMainnetWallet)
    })

    it('updates activeWalletName in store', async () => {
      const store = useStore()
      store.setWallet(mockMainnetWallet as never)

      await store.switchWallet('differentWallet')

      expect(store.activeWalletName).toBe('differentWallet')
    })

    it('persists activeWalletName to localStorage', async () => {
      const store = useStore()
      store.setWallet(mockMainnetWallet as never)

      await store.switchWallet('persistedWallet')

      expect(localStorageMock.setItem).toHaveBeenCalledWith('activeWalletName', 'persistedWallet')
    })

    it('sets _wallet to mainnet wallet instance', async () => {
      const store = useStore()
      store.setWallet(mockMainnetWallet as never)

      await store.switchWallet('newWallet')

      // Verify wallet was set by checking its properties
      expect(store._wallet?.network).toBe('mainnet')
      expect(store._wallet?.cashaddr).toBe(mockMainnetWallet.cashaddr)
    })

    it('sets _wallet to chipnet wallet instance', async () => {
      localStorageMock.setItem('network', 'chipnet')
      mockTestNetWalletNamed.mockResolvedValue(mockChipnetWallet)
      const store = useStore()
      store.setWallet(mockMainnetWallet as never)

      await store.switchWallet('newWallet')

      // Verify chipnet wallet was set by checking its properties
      expect(store._wallet?.network).toBe('chipnet')
      expect(store._wallet?.cashaddr).toBe(mockChipnetWallet.cashaddr)
    })
  })

  describe('network fallback for network-specific wallets', () => {
    it('switches to mainnet when wallet only exists on mainnet and current network is chipnet', async () => {
      localStorageMock.setItem('network', 'chipnet')
      mockWalletNamed.mockResolvedValue(mockMainnetWallet)
      const store = useStore()
      store.setWallet(mockChipnetWallet as never)
      // Set up availableWallets with a mainnet-only wallet
      store.availableWallets = [
        { name: 'mainnetOnlyWallet', hasMainnet: true, hasChipnet: false }
      ]

      const result = await store.switchWallet('mainnetOnlyWallet')

      expect(result.success).toBe(true)
      expect(result.networkChanged).toBe('mainnet')
      expect(store.activeWalletName).toBe('mainnetOnlyWallet')
      expect(localStorageMock.setItem).toHaveBeenCalledWith('activeWalletName', 'mainnetOnlyWallet')
      // Should NOT have called TestNetWallet.named (we're switching away from chipnet)
      expect(mockTestNetWalletNamed).not.toHaveBeenCalled()
      // changeNetwork is fire-and-forget, wait a tick for its effects
      await new Promise(r => setTimeout(r, 0))
      // Verify network was changed and correct wallet loader was called
      expect(localStorageMock.setItem).toHaveBeenCalledWith('network', 'mainnet')
      expect(mockWalletNamed).toHaveBeenCalledWith('mainnetOnlyWallet')
    })

    it('switches to chipnet when wallet only exists on chipnet and current network is mainnet', async () => {
      localStorageMock.setItem('network', 'mainnet')
      mockTestNetWalletNamed.mockResolvedValue(mockChipnetWallet)
      const store = useStore()
      store.setWallet(mockMainnetWallet as never)
      // Set up availableWallets with a chipnet-only wallet
      store.availableWallets = [
        { name: 'chipnetOnlyWallet', hasMainnet: false, hasChipnet: true }
      ]

      const result = await store.switchWallet('chipnetOnlyWallet')

      expect(result.success).toBe(true)
      expect(result.networkChanged).toBe('chipnet')
      expect(store.activeWalletName).toBe('chipnetOnlyWallet')
      expect(localStorageMock.setItem).toHaveBeenCalledWith('activeWalletName', 'chipnetOnlyWallet')
      // Should NOT have called Wallet.named (we're switching away from mainnet)
      expect(mockWalletNamed).not.toHaveBeenCalled()
      // changeNetwork is fire-and-forget, wait a tick for its effects
      await new Promise(r => setTimeout(r, 0))
      // Verify network was changed and correct wallet loader was called
      expect(localStorageMock.setItem).toHaveBeenCalledWith('network', 'chipnet')
      expect(mockTestNetWalletNamed).toHaveBeenCalledWith('chipnetOnlyWallet')
    })

    it('does not change network when wallet exists on current network', async () => {
      localStorageMock.setItem('network', 'mainnet')
      mockWalletNamed.mockResolvedValue(mockMainnetWallet)
      const store = useStore()
      store.setWallet(mockMainnetWallet as never)
      // Wallet exists on both networks
      store.availableWallets = [
        { name: 'bothNetworks', hasMainnet: true, hasChipnet: true }
      ]

      const result = await store.switchWallet('bothNetworks')

      expect(result.success).toBe(true)
      expect(result.networkChanged).toBeUndefined()
      expect(mockWalletNamed).toHaveBeenCalledWith('bothNetworks')
    })

    it('loads wallet normally when not in availableWallets (fresh wallet)', async () => {
      localStorageMock.setItem('network', 'mainnet')
      mockWalletNamed.mockResolvedValue(mockMainnetWallet)
      const store = useStore()
      store.setWallet(mockMainnetWallet as never)
      store.availableWallets = [] // Empty list

      const result = await store.switchWallet('unknownWallet')

      expect(result.success).toBe(true)
      expect(result.networkChanged).toBeUndefined()
      expect(mockWalletNamed).toHaveBeenCalledWith('unknownWallet')
    })
  })

  describe('error handling', () => {
    it('throws when wallet loading fails', async () => {
      localStorageMock.setItem('network', 'mainnet')
      mockWalletNamed.mockRejectedValue(new Error('Wallet not found'))

      const store = useStore()
      store.setWallet(mockMainnetWallet as never)

      await expect(store.switchWallet('nonexistentWallet')).rejects.toThrowError()
    })

    it('does not mutate state when wallet loading fails', async () => {
      localStorageMock.setItem('network', 'mainnet')
      localStorageMock.setItem('activeWalletName', 'originalWallet')
      localStorageMock.setItem.mockClear()
      mockWalletNamed.mockRejectedValue(new Error('Wallet not found'))

      const store = useStore()
      store.setWallet(mockMainnetWallet as never)
      store.activeWalletName = 'originalWallet'
      store.displayView = 5
      const originalWalletRef = store._wallet

      try {
        await store.switchWallet('failedWallet')
      } catch {
        // Expected to throw
      }

      // No state should be mutated on failure
      expect(store.activeWalletName).toBe('originalWallet')
      expect(store._wallet).toBe(originalWalletRef)
      expect(store.displayView).toBe(5)
      expect(localStorageMock.setItem).not.toHaveBeenCalledWith('activeWalletName', 'failedWallet')
    })
  })
})

describe('deleteWallet', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    localStorageMock.clear()
    setActivePinia(createPinia())
    mockGetAllWalletsWithNetworkInfo.mockResolvedValue([])
  })

  it('throws when trying to delete the active wallet', async () => {
    const store = useStore()
    store.setWallet(mockMainnetWallet as never)
    // activeWalletName defaults to 'mywallet'

    await expect(store.deleteWallet('mywallet')).rejects.toThrowError()
  })

  it('does not call deleteWalletFromDb when trying to delete active wallet', async () => {
    const store = useStore()
    store.setWallet(mockMainnetWallet as never)

    try {
      await store.deleteWallet('mywallet')
    } catch {
      // Expected to throw
    }

    expect(mockDeleteWalletFromDb).not.toHaveBeenCalled()
  })

  it('deletes wallet from both mainnet and testnet databases', async () => {
    const store = useStore()
    store.setWallet(mockMainnetWallet as never)

    await store.deleteWallet('otherWallet')

    expect(mockDeleteWalletFromDb).toHaveBeenCalledWith('otherWallet', 'bitcoincash')
    expect(mockDeleteWalletFromDb).toHaveBeenCalledWith('otherWallet', 'bchtest')
    expect(mockDeleteWalletFromDb).toHaveBeenCalledTimes(2)
  })

  it('refreshes available wallets after deletion', async () => {
    const store = useStore()
    store.setWallet(mockMainnetWallet as never)

    await store.deleteWallet('otherWallet')

    expect(mockGetAllWalletsWithNetworkInfo).toHaveBeenCalled()
  })

  it('propagates error if mainnet deletion fails (testnet not attempted)', async () => {
    mockDeleteWalletFromDb.mockRejectedValueOnce(new Error('DB error'))
    const store = useStore()
    store.setWallet(mockMainnetWallet as never)

    await expect(store.deleteWallet('otherWallet')).rejects.toThrowError()

    // Only mainnet deletion was attempted before failure
    expect(mockDeleteWalletFromDb).toHaveBeenCalledTimes(1)
    expect(mockDeleteWalletFromDb).toHaveBeenCalledWith('otherWallet', 'bitcoincash')
    // Wallet list not refreshed on failure
    expect(mockGetAllWalletsWithNetworkInfo).not.toHaveBeenCalled()
  })

  it('propagates error if testnet deletion fails (mainnet already deleted)', async () => {
    mockDeleteWalletFromDb
      .mockResolvedValueOnce(undefined) // mainnet succeeds
      .mockRejectedValueOnce(new Error('DB error')) // testnet fails
    const store = useStore()
    store.setWallet(mockMainnetWallet as never)

    await expect(store.deleteWallet('otherWallet')).rejects.toThrowError()

    // Both deletions were attempted
    expect(mockDeleteWalletFromDb).toHaveBeenCalledTimes(2)
    // Wallet list not refreshed on failure
    expect(mockGetAllWalletsWithNetworkInfo).not.toHaveBeenCalled()
  })
})
