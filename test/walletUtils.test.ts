/**
 * Tests generated by Claude
 */
import { describe, it, expect, vi, beforeEach } from 'vitest'

// Import mocks FIRST
import {
  mockWalletNamed,
  mockWalletReplaceNamed,
  mockTestNetWalletReplaceNamed,
  mockNamedWalletExistsInDb,
  mockSetWallet,
  mockRefreshAvailableWallets,
  mockSetWalletCreatedAt,
  mockSetBackupStatus,
  localStorageMock,
} from './mocks/walletUtils.mocks'

// Import module under test after mocks
import { createNewWallet, importWallet } from '../src/utils/walletUtils'

describe('createNewWallet', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('input validation - no side effects on failure', () => {
    it('rejects empty name and makes no wallet/store calls', async () => {
      const result = await createNewWallet('')

      expect(result.success).toBe(false)
      // Verify NO side effects occurred
      expect(mockNamedWalletExistsInDb).not.toHaveBeenCalled()
      expect(mockWalletNamed).not.toHaveBeenCalled()
      expect(mockTestNetWalletReplaceNamed).not.toHaveBeenCalled()
      expect(mockSetWallet).not.toHaveBeenCalled()
      expect(localStorageMock.setItem).not.toHaveBeenCalled()
    })

    it('rejects whitespace-only name and makes no wallet/store calls', async () => {
      const result = await createNewWallet('   \t\n  ')

      expect(result.success).toBe(false)
      expect(mockNamedWalletExistsInDb).not.toHaveBeenCalled()
      expect(mockWalletNamed).not.toHaveBeenCalled()
    })

    it('rejects existing wallet name and makes no wallet creation calls', async () => {
      mockNamedWalletExistsInDb.mockResolvedValue(true)

      const result = await createNewWallet('existingWallet')

      expect(result.success).toBe(false)
      expect(result.success === false && result.isUserError).toBe(true)
      // DB check happened, but no wallet creation
      expect(mockNamedWalletExistsInDb).toHaveBeenCalledWith('existingWallet', 'bitcoincash')
      expect(mockWalletNamed).not.toHaveBeenCalled()
      expect(mockTestNetWalletReplaceNamed).not.toHaveBeenCalled()
      expect(mockSetWallet).not.toHaveBeenCalled()
    })
  })

  describe('name handling', () => {
    it('trims whitespace from name before all operations', async () => {
      mockNamedWalletExistsInDb.mockResolvedValue(false)
      const mockWallet = { toDbString: vi.fn().mockReturnValue('seed:mainnet:x:path') }
      mockWalletNamed.mockResolvedValue(mockWallet)

      await createNewWallet('  myWallet  ')

      expect(mockNamedWalletExistsInDb).toHaveBeenCalledWith('myWallet', 'bitcoincash')
      expect(mockWalletNamed).toHaveBeenCalledWith('myWallet')
    })

    it('handles unicode wallet names', async () => {
      mockNamedWalletExistsInDb.mockResolvedValue(false)
      const mockWallet = { toDbString: vi.fn().mockReturnValue('seed:mainnet:x:path') }
      mockWalletNamed.mockResolvedValue(mockWallet)

      const unicodeName = '我的钱包'
      await createNewWallet(unicodeName)

      expect(mockNamedWalletExistsInDb).toHaveBeenCalledWith(unicodeName, 'bitcoincash')
      expect(mockWalletNamed).toHaveBeenCalledWith(unicodeName)
    })
  })

  describe('successful creation - side effects', () => {
    const mockWallet = { toDbString: vi.fn().mockReturnValue('seed:mainnet:testseed:m/44\'/145\'/0\'/0/0') }

    beforeEach(() => {
      mockNamedWalletExistsInDb.mockResolvedValue(false)
      mockWalletNamed.mockResolvedValue(mockWallet)
      mockTestNetWalletReplaceNamed.mockResolvedValue(undefined)
    })

    it('creates mainnet wallet via Wallet.named', async () => {
      await createNewWallet('newWallet')

      expect(mockWalletNamed).toHaveBeenCalledWith('newWallet')
      expect(mockWalletNamed).toHaveBeenCalledTimes(1)
    })

    it('creates testnet wallet with converted walletId', async () => {
      await createNewWallet('newWallet')

      // toDbString returns mainnet id, which gets converted to testnet
      expect(mockTestNetWalletReplaceNamed).toHaveBeenCalledWith(
        'newWallet',
        'seed:testnet:testseed:m/44\'/145\'/0\'/0/0' // mainnet → testnet
      )
    })

    it('updates store with wallet instance', async () => {
      await createNewWallet('newWallet')

      expect(mockSetWallet).toHaveBeenCalledWith(mockWallet)
    })

    it('persists active wallet name to localStorage', async () => {
      await createNewWallet('newWallet')

      expect(localStorageMock.setItem).toHaveBeenCalledWith('activeWalletName', 'newWallet')
    })

    it('refreshes available wallets list', async () => {
      await createNewWallet('newWallet')

      expect(mockRefreshAvailableWallets).toHaveBeenCalled()
    })

    it('records wallet creation date in settings', async () => {
      await createNewWallet('newWallet')

      expect(mockSetWalletCreatedAt).toHaveBeenCalledWith('newWallet')
    })

    it('returns success with trimmed wallet name', async () => {
      const result = await createNewWallet('  newWallet  ')

      expect(result.success).toBe(true)
      expect(result.success && result.walletName).toBe('newWallet')
    })
  })

  describe('error handling - dependency failures', () => {
    beforeEach(() => {
      mockNamedWalletExistsInDb.mockResolvedValue(false)
    })

    it('returns non-user error when Wallet.named throws', async () => {
      mockWalletNamed.mockRejectedValue(new Error('Network error'))

      const result = await createNewWallet('newWallet')

      expect(result.success).toBe(false)
      expect(result.success === false && result.isUserError).toBe(false)
      // Verify no partial state mutations
      expect(mockSetWallet).not.toHaveBeenCalled()
      expect(localStorageMock.setItem).not.toHaveBeenCalled()
    })

    it('returns non-user error when TestNetWallet.replaceNamed throws', async () => {
      const mockWallet = { toDbString: vi.fn().mockReturnValue('seed:mainnet:x:path') }
      mockWalletNamed.mockResolvedValue(mockWallet)
      mockTestNetWalletReplaceNamed.mockRejectedValue(new Error('DB error'))

      const result = await createNewWallet('newWallet')

      expect(result.success).toBe(false)
      expect(result.success === false && result.isUserError).toBe(false)
    })

    it('returns non-user error when DB existence check throws', async () => {
      mockNamedWalletExistsInDb.mockRejectedValue(new Error('IndexedDB unavailable'))

      const result = await createNewWallet('newWallet')

      expect(result.success).toBe(false)
      expect(result.success === false && result.isUserError).toBe(false)
      expect(mockWalletNamed).not.toHaveBeenCalled()
    })
  })
})

describe('importWallet', () => {
  const validSeedPhrase = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about'

  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('input validation - no side effects on failure', () => {
    it('rejects empty name and makes no wallet calls', async () => {
      const result = await importWallet({
        name: '',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(result.success).toBe(false)
      expect(mockNamedWalletExistsInDb).not.toHaveBeenCalled()
      expect(mockWalletReplaceNamed).not.toHaveBeenCalled()
    })

    it('rejects existing wallet name and makes no wallet creation calls', async () => {
      mockNamedWalletExistsInDb.mockResolvedValue(true)

      const result = await importWallet({
        name: 'existingWallet',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(result.success).toBe(false)
      expect(mockWalletReplaceNamed).not.toHaveBeenCalled()
      expect(mockTestNetWalletReplaceNamed).not.toHaveBeenCalled()
    })

    it('rejects empty seed phrase and makes no wallet calls', async () => {
      mockNamedWalletExistsInDb.mockResolvedValue(false)

      const result = await importWallet({
        name: 'newWallet',
        seedPhrase: '',
        seedPhraseValid: false,
        derivationPath: 'standard'
      })

      expect(result.success).toBe(false)
      expect(mockWalletReplaceNamed).not.toHaveBeenCalled()
    })

    it('rejects invalid seed phrase and makes no wallet calls', async () => {
      mockNamedWalletExistsInDb.mockResolvedValue(false)

      const result = await importWallet({
        name: 'newWallet',
        seedPhrase: 'invalid words',
        seedPhraseValid: false,
        derivationPath: 'standard'
      })

      expect(result.success).toBe(false)
      expect(mockWalletReplaceNamed).not.toHaveBeenCalled()
    })
  })

  describe('derivation path handling', () => {
    beforeEach(() => {
      mockNamedWalletExistsInDb.mockResolvedValue(false)
      mockWalletReplaceNamed.mockResolvedValue(undefined)
      mockTestNetWalletReplaceNamed.mockResolvedValue(undefined)
      mockWalletNamed.mockResolvedValue({})
    })

    it('uses BCH standard derivation path m/44\'/145\'/0\'/0/0', async () => {
      await importWallet({
        name: 'wallet',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(mockWalletReplaceNamed).toHaveBeenCalledWith(
        'wallet',
        `seed:mainnet:${validSeedPhrase}:m/44'/145'/0'/0/0`
      )
      expect(mockTestNetWalletReplaceNamed).toHaveBeenCalledWith(
        'wallet',
        `seed:testnet:${validSeedPhrase}:m/44'/145'/0'/0/0`
      )
    })

    it('uses bitcoin.com derivation path m/44\'/0\'/0\'/0/0', async () => {
      await importWallet({
        name: 'wallet',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'bitcoindotcom'
      })

      expect(mockWalletReplaceNamed).toHaveBeenCalledWith(
        'wallet',
        `seed:mainnet:${validSeedPhrase}:m/44'/0'/0'/0/0`
      )
      expect(mockTestNetWalletReplaceNamed).toHaveBeenCalledWith(
        'wallet',
        `seed:testnet:${validSeedPhrase}:m/44'/0'/0'/0/0`
      )
    })
  })

  describe('successful import - side effects', () => {
    const mockWallet = {}

    beforeEach(() => {
      mockNamedWalletExistsInDb.mockResolvedValue(false)
      mockWalletReplaceNamed.mockResolvedValue(undefined)
      mockTestNetWalletReplaceNamed.mockResolvedValue(undefined)
      mockWalletNamed.mockResolvedValue(mockWallet)
    })

    it('creates both mainnet and testnet wallets', async () => {
      await importWallet({
        name: 'imported',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(mockWalletReplaceNamed).toHaveBeenCalledTimes(1)
      expect(mockTestNetWalletReplaceNamed).toHaveBeenCalledTimes(1)
    })

    it('loads the mainnet wallet after creation', async () => {
      await importWallet({
        name: 'imported',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(mockWalletNamed).toHaveBeenCalledWith('imported')
    })

    it('updates store with loaded wallet', async () => {
      await importWallet({
        name: 'imported',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(mockSetWallet).toHaveBeenCalledWith(mockWallet)
    })

    it('persists active wallet name to localStorage', async () => {
      await importWallet({
        name: 'imported',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(localStorageMock.setItem).toHaveBeenCalledWith('activeWalletName', 'imported')
    })

    it('marks wallet backup status as imported (user demonstrated having seed)', async () => {
      await importWallet({
        name: 'imported',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(mockSetBackupStatus).toHaveBeenCalledWith('imported', 'imported')
    })

    it('records wallet creation date', async () => {
      await importWallet({
        name: 'imported',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(mockSetWalletCreatedAt).toHaveBeenCalledWith('imported')
    })
  })

  describe('error handling - dependency failures', () => {
    beforeEach(() => {
      mockNamedWalletExistsInDb.mockResolvedValue(false)
    })

    it('returns non-user error when Wallet.replaceNamed throws', async () => {
      mockWalletReplaceNamed.mockRejectedValue(new Error('Storage full'))

      const result = await importWallet({
        name: 'wallet',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(result.success).toBe(false)
      expect(result.success === false && result.isUserError).toBe(false)
      // No partial state
      expect(mockSetWallet).not.toHaveBeenCalled()
      expect(localStorageMock.setItem).not.toHaveBeenCalled()
    })

    it('returns non-user error when Wallet.named throws after creation', async () => {
      mockWalletReplaceNamed.mockResolvedValue(undefined)
      mockTestNetWalletReplaceNamed.mockResolvedValue(undefined)
      mockWalletNamed.mockRejectedValue(new Error('Corrupted wallet'))

      const result = await importWallet({
        name: 'wallet',
        seedPhrase: validSeedPhrase,
        seedPhraseValid: true,
        derivationPath: 'standard'
      })

      expect(result.success).toBe(false)
      expect(result.success === false && result.isUserError).toBe(false)
    })
  })
})
